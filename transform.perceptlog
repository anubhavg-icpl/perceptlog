# Production-ready Linux Authentication Log Mapper for OCSF v1.6.0
# Transforms Linux auth.log entries to OCSF Authentication events
# Compliant with OCSF Authentication [3002] class specification
# https://schema.ocsf.io/doc/swagger.json

# Performance: Cache commonly used values
_now_ts = now()
_unix_ts = to_unix_timestamp(_now_ts)
_current_year = format_timestamp!(_now_ts, format: "%Y")
_tz_str = format_timestamp!(_now_ts, format: "%z")

# Initialize OCSF event structure with all required fields
ocsf = {
  "metadata": {
    "uid": uuid_v7(),
    "version": "1.6.0",
    "product": {
      "vendor_name": "Linux",
      "name": "Authentication Logs",
      "version": "system"
    },
    "logged_time": _unix_ts,
    "log_name": "auth.log",
    "log_provider": "syslog",
    "event_code": "auth_event",
    "profiles": ["host"],
    "log_version": "1.0"
  },
  "category_uid": 3,
  "category_name": "Identity & Access Management",
  "class_uid": 3002,
  "class_name": "Authentication",
  "raw_data": encode_json(.),
  "observables": []
}

# Production error tracking
_parse_errors = []

# Validate required input field
if is_null(.message) || !is_string(.message) {
  # Log error for debugging
  _parse_errors = push(_parse_errors, "Invalid or missing message field")
  
  # Set minimal required fields for events without proper message format
  ocsf.time = _unix_ts
  ocsf.user = {"name": "unknown", "uid": "unknown"}
  ocsf.service = {"name": "unknown"}
  ocsf.message = to_string(.message) ?? "No message"
  ocsf.activity_id = 0
  ocsf.activity_name = "Unknown" 
  ocsf.status = "Unknown"
  ocsf.status_id = 0
  ocsf.severity_id = 0
  ocsf.severity = "Unknown"
  ocsf.type_uid = 300200
  ocsf.type_name = "Authentication: Unknown"
  ocsf.metadata.log_level = "ERROR"
  ocsf.metadata.original_time = format_timestamp!(_now_ts, format: "%Y-%m-%d %H:%M:%S")
  ocsf.unmapped = {"parse_errors": _parse_errors, "original_message": .message}
} else {
  # Extract timestamp, hostname, process, and message content
  auth_pattern = r'^(?P<timestamp>\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+(?P<hostname>\S+)\s+(?P<process>\S+?)(?:\[(?P<pid>\d+)\])?:\s*(?P<content>.*)$'
  match, _ = parse_regex(.message, pattern: auth_pattern)
  
  if !is_null(match) {
    # Parse timestamp with optimized format detection
    timestamp_str = match.timestamp
    parsed_ts = null
    
    # Try multiple timestamp formats for robustness
    # VRL doesn't support for loops, try formats sequentially
    parsed_ts, _ = parse_timestamp(timestamp_str, format: "%b %d %H:%M:%S")
    if is_null(parsed_ts) {
      parsed_ts, _ = parse_timestamp(timestamp_str, format: "%b%e %H:%M:%S")
    }
    if is_null(parsed_ts) {
      parsed_ts, _ = parse_timestamp(timestamp_str, format: "%b  %d %H:%M:%S")
    }
    
    if !is_null(parsed_ts) {
      # Set year to current year for proper timestamp conversion
      timestamp_with_year = format_timestamp!(parsed_ts, format: "%Y-%m-%d %H:%M:%S")
      timestamp_with_year = replace(timestamp_with_year, pattern: r'^\d{4}', with: _current_year)
      final_ts = parse_timestamp!(timestamp_with_year, format: "%Y-%m-%d %H:%M:%S")

      ocsf.time = to_unix_timestamp(final_ts)
      ocsf.metadata.original_time = timestamp_str
      
      # Set timezone offset (cached)
      tz_int, _ = parse_int(_tz_str)
      if !is_null(tz_int) {
        ocsf.timezone_offset = to_int(tz_int / 100)
      }
    } else {
      # Fallback to current time if parsing fails
      ocsf.time = _unix_ts
      _parse_errors = push(_parse_errors, "Failed to parse timestamp: " + timestamp_str)
    }
    
    # Set service endpoint (required constraint: at least one of dst_endpoint, service)
    ocsf.service = {"name": match.process}
    
    # Optional logon process information - needs both cmd_line and uid to satisfy constraint
    ocsf.logon_process = {
      "name": match.process,
      "cmd_line": match.process,
      "uid": "0"  # Default to root for system processes
    }
    if !is_null(match.pid) {
      pid_int, pid_err = parse_int(match.pid)
      if pid_err == null {
        ocsf.logon_process.pid = pid_int
      }
    }
    
    _content = to_string(match.content)

    # SSH Authentication Events - Protocol ID 99 (Other)
    if match.process == "sshd" || contains(_content, "sshd") {
      ocsf.auth_protocol = "SSH"
      ocsf.auth_protocol_id = 99  # Other - SSH not in enum
      ocsf.is_remote = true
      ocsf.is_mfa = false
      ocsf.is_cleartext = false  # SSH is encrypted
      ocsf.logon_type_id = 3  # Network
      ocsf.logon_type = "Network"
      
      # Determine activity type and status
      if contains(_content, "Accepted password") {
        ocsf.activity_id = 1
        ocsf.activity_name = "Logon"
        ocsf.type_uid = 300201  # 3002*100 + 1
        ocsf.type_name = "Authentication: Logon"
        ocsf.status = "Success"
        ocsf.status_id = 1
        ocsf.status_detail = "LOGON_USER_INITIATED"
        ocsf.severity_id = 1
        ocsf.severity = "Informational"
        
        # Extract user and source IP
        login_pattern = r'Accepted password for (?P<user>\S+) from (?P<src_ip>\S+) port (?P<port>\d+)'
        login_match, _ = parse_regex(_content, pattern: login_pattern)
        if !is_null(login_match) {
          ocsf.actor = {"user": {"name": login_match.user, "uid": login_match.user}}
          ocsf.user = {"name": login_match.user, "uid": login_match.user}
          port_int, port_err = parse_int(login_match.port)
          if port_err == null {
            ocsf.src_endpoint = {"ip": login_match.src_ip, "hostname": match.hostname, "port": port_int}
          } else {
            ocsf.src_endpoint = {"ip": login_match.src_ip, "hostname": match.hostname}
          }
        }
        
      } else if contains(_content, "Failed password") {
        ocsf.activity_id = 1
        ocsf.activity_name = "Logon"
        ocsf.type_uid = 300201  # 3002*100 + 1
        ocsf.type_name = "Authentication: Logon"
        ocsf.status = "Failure"
        ocsf.status_id = 2
        ocsf.status_code = "PAM_AUTH_FAIL"
        ocsf.severity_id = 3
        ocsf.severity = "Medium"

        # Extract user and source IP - handles both "invalid user" and regular failures
        fail_match = null
        if contains(_content, "invalid user") {
          fail_match, _ = parse_regex(_content, pattern: r'Failed password for invalid user (?P<user>\S+) from (?P<src_ip>\S+) port (?P<port>\d+)')
        } else {
          fail_match, _ = parse_regex(_content, pattern: r'Failed password for\s+(?P<user>\S+) from (?P<src_ip>\S+) port (?P<port>\d+)')
        }
        if !is_null(fail_match) {
          ocsf.actor = {"user": {"name": fail_match.user, "uid": fail_match.user}}
          ocsf.user = {"name": fail_match.user, "uid": fail_match.user}
          port_int, port_err = parse_int(fail_match.port)
          if port_err == null {
            ocsf.src_endpoint = {"ip": fail_match.src_ip, "hostname": match.hostname, "port": port_int}
          } else {
            ocsf.src_endpoint = {"ip": fail_match.src_ip, "hostname": match.hostname}
          }
        }

      } else if contains(_content, "Failed none") {
        # Null authentication method failure
        ocsf.activity_id = 6
        ocsf.activity_name = "Preauth"
        ocsf.type_uid = 300206  # 3002*100 + 6
        ocsf.type_name = "Authentication: Preauth"
        ocsf.status = "Failure"
        ocsf.status_id = 2
        ocsf.status_code = "AUTH_METHOD_NONE_FAIL"
        ocsf.severity_id = 3
        ocsf.severity = "Medium"

        # Extract details
        none_pattern = r'Failed none for (?:invalid user )?(?P<user>\S+) from (?P<src_ip>\S+) port (?P<port>\d+)'
        none_match, _ = parse_regex(_content, pattern: none_pattern)
        if !is_null(none_match) {
          ocsf.actor = {"user": {"name": none_match.user, "uid": none_match.user}}
          ocsf.user = {"name": none_match.user, "uid": none_match.user}
          port_int, port_err = parse_int(none_match.port)
          if port_err == null {
            ocsf.src_endpoint = {"ip": none_match.src_ip, "hostname": match.hostname, "port": port_int}
          } else {
            ocsf.src_endpoint = {"ip": none_match.src_ip, "hostname": match.hostname}
          }
        }

      } else if contains(_content, "authentication failure") {
        ocsf.activity_id = 6
        ocsf.activity_name = "Preauth"
        ocsf.type_uid = 300206  # 3002*100 + 6
        ocsf.type_name = "Authentication: Preauth"
        ocsf.status = "Failure"
        ocsf.status_id = 2
        ocsf.status_code = "PAM_PREAUTH_FAIL"
        ocsf.severity_id = 3
        ocsf.severity = "Medium"
        
        # Extract failure details - enhanced to handle missing user field
        auth_fail_pattern = r'pam_unix\(sshd:auth\): authentication failure;.*?rhost=(?P<src_ip>\S+)(?:.*?user=(?P<user>\S+))?'
        fail_match, _ = parse_regex(_content, pattern: auth_fail_pattern)
        if !is_null(fail_match) {
          ocsf.src_endpoint = {"ip": fail_match.src_ip, "hostname": match.hostname}
          if !is_null(fail_match.user) && fail_match.user != "" {
            ocsf.actor = {"user": {"name": fail_match.user, "uid": fail_match.user}}
            ocsf.user = {"name": fail_match.user, "uid": fail_match.user}
          } else {
            ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}
            ocsf.user = {"name": "unknown", "uid": "unknown"}
          }
        }
        
      } else if contains(_content, "session opened") {
        ocsf.activity_id = 1
        ocsf.activity_name = "Logon"
        ocsf.type_uid = 300201  # 3002*100 + 1
        ocsf.type_name = "Authentication: Logon"
        ocsf.status = "Success"
        ocsf.status_id = 1
        ocsf.status_detail = "SESSION_OPENED"
        ocsf.severity_id = 1
        ocsf.severity = "Informational"
        
        # Extract session details
        session_pattern = r'pam_unix\(sshd:session\): session opened for user (?P<user>\S+)'
        session_match, _ = parse_regex(_content, pattern: session_pattern)
        if !is_null(session_match) {
          ocsf.actor = {"user": {"name": session_match.user, "uid": session_match.user}}
          ocsf.user = {"name": session_match.user, "uid": session_match.user}
        }
        
      } else if contains(_content, "session closed") {
        ocsf.activity_id = 2
        ocsf.activity_name = "Logoff"
        ocsf.type_uid = 300202  # 3002*100 + 2
        ocsf.type_name = "Authentication: Logoff"
        ocsf.status = "Success"
        ocsf.status_id = 1
        ocsf.status_detail = "SESSION_CLOSED"
        ocsf.severity_id = 1
        ocsf.severity = "Informational"
        
        # Extract session details
        session_pattern = r'pam_unix\(sshd:session\): session closed for user (?P<user>\S+)'
        session_match, _ = parse_regex(_content, pattern: session_pattern)
        if !is_null(session_match) {
          ocsf.actor = {"user": {"name": session_match.user, "uid": session_match.user}}
          ocsf.user = {"name": session_match.user, "uid": session_match.user}
        }
        
      } else if contains(_content, "Received disconnect") {
        ocsf.activity_id = 2
        ocsf.activity_name = "Logoff"
        ocsf.type_uid = 300202  # 3002*100 + 2
        ocsf.type_name = "Authentication: Logoff"
        ocsf.status = "Success"
        ocsf.status_id = 1
        ocsf.status_detail = "DISCONNECT_BY_USER"
        ocsf.severity_id = 1
        ocsf.severity = "Informational"

        # Extract disconnect details
        disc_pattern = r'Received disconnect from (?P<src_ip>\S+) port (?P<port>\d+)'
        disc_match, _ = parse_regex(_content, pattern: disc_pattern)
        if !is_null(disc_match) {
          port_int, port_err = parse_int(disc_match.port)
          if port_err == null {
            ocsf.src_endpoint = {"ip": disc_match.src_ip, "hostname": match.hostname, "port": port_int}
          } else {
            ocsf.src_endpoint = {"ip": disc_match.src_ip, "hostname": match.hostname}
          }
        }

        # Set required user field (use "unknown" if not available)
        ocsf.user = {"name": "unknown", "uid": "unknown"}
        ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}

      } else if contains(_content, "Connection closed") {
        ocsf.activity_id = 2
        ocsf.activity_name = "Logoff"
        ocsf.type_uid = 300202  # 3002*100 + 2
        ocsf.type_name = "Authentication: Logoff"
        ocsf.status = "Success"
        ocsf.status_id = 1
        ocsf.status_detail = "CONNECTION_CLOSED"
        ocsf.severity_id = 1
        ocsf.severity = "Informational"

        # Extract connection details - enhanced to handle "authenticating user" prefix
        conn_match = null
        if contains(_content, "authenticating user") {
          conn_match, _ = parse_regex(_content, pattern: r'Connection closed by authenticating user (?P<user>\S+) (?P<src_ip>\S+) port (?P<port>\d+)')
        } else {
          conn_match, _ = parse_regex(_content, pattern: r'Connection closed by (?P<user>\S+) (?P<src_ip>\S+) port (?P<port>\d+)')
        }
        if !is_null(conn_match) {
          ocsf.actor = {"user": {"name": conn_match.user, "uid": conn_match.user}}
          ocsf.user = {"name": conn_match.user, "uid": conn_match.user}
          port_int, port_err = parse_int(conn_match.port)
          if port_err == null {
            ocsf.src_endpoint = {"ip": conn_match.src_ip, "hostname": match.hostname, "port": port_int}
          }
        } else {
          # Set required user field even if pattern doesn't match
          ocsf.user = {"name": "unknown", "uid": "unknown"}
          ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}
        }
        
      } else if contains(_content, "Invalid user") {
        ocsf.activity_id = 6
        ocsf.activity_name = "Preauth"
        ocsf.type_uid = 300206  # 3002*100 + 6
        ocsf.type_name = "Authentication: Preauth"
        ocsf.status = "Failure"
        ocsf.status_id = 2
        ocsf.status_code = "INVALID_USER"
        ocsf.severity_id = 3
        ocsf.severity = "Medium"
        
        # Extract invalid user details
        invalid_pattern = r'Invalid user (?P<user>\S+) from (?P<src_ip>\S+) port (?P<port>\d+)'
        invalid_match, _ = parse_regex(_content, pattern: invalid_pattern)
        if !is_null(invalid_match) {
          ocsf.actor = {"user": {"name": invalid_match.user, "uid": invalid_match.user}}
          ocsf.user = {"name": invalid_match.user, "uid": invalid_match.user}
          port_int, port_err = parse_int(invalid_match.port)
          if port_err == null {
            ocsf.src_endpoint = {"ip": invalid_match.src_ip, "hostname": match.hostname, "port": port_int}
          } else {
            ocsf.src_endpoint = {"ip": invalid_match.src_ip, "hostname": match.hostname}
          }
        }

      } else if contains(_content, "Valid user") {
        # Valid user check (pre-authentication verification)
        ocsf.activity_id = 6
        ocsf.activity_name = "Preauth"
        ocsf.type_uid = 300206  # 3002*100 + 6
        ocsf.type_name = "Authentication: Preauth"
        ocsf.status = "Success"
        ocsf.status_id = 1
        ocsf.status_detail = "VALID_USER_CHECK"
        ocsf.severity_id = 1
        ocsf.severity = "Informational"

        # Extract valid user details
        valid_pattern = r'Valid user (?P<user>\S+) from (?P<src_ip>\S+) port (?P<port>\d+)'
        valid_match, _ = parse_regex(_content, pattern: valid_pattern)
        if !is_null(valid_match) {
          ocsf.actor = {"user": {"name": valid_match.user, "uid": valid_match.user}}
          ocsf.user = {"name": valid_match.user, "uid": valid_match.user}
          port_int, port_err = parse_int(valid_match.port)
          if port_err == null {
            ocsf.src_endpoint = {"ip": valid_match.src_ip, "hostname": match.hostname, "port": port_int}
          } else {
            ocsf.src_endpoint = {"ip": valid_match.src_ip, "hostname": match.hostname}
          }
        }

      } else if contains(_content, "check pass") {
        # Password check operation (usually for invalid users)
        ocsf.activity_id = 6
        ocsf.activity_name = "Preauth"
        ocsf.type_uid = 300206  # 3002*100 + 6
        ocsf.type_name = "Authentication: Preauth"
        ocsf.status = "Failure"
        ocsf.status_id = 2
        ocsf.status_code = "PASSWORD_CHECK_UNKNOWN_USER"
        ocsf.severity_id = 2
        ocsf.severity = "Low"
        ocsf.user = {"name": "unknown", "uid": "unknown"}
        ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}

      } else if contains(_content, "Server listening") {
        # SSH service start
        ocsf.activity_id = 99
        ocsf.activity_name = "Other"
        ocsf.type_uid = 300299  # 3002*100 + 99
        ocsf.type_name = "Authentication: Other"
        ocsf.status = "Success"
        ocsf.status_id = 1
        ocsf.status_detail = "SERVICE_START"
        ocsf.severity_id = 1
        ocsf.severity = "Informational"
        ocsf.user = {"name": "system", "uid": "system"}
        ocsf.actor = {"user": {"name": "system", "uid": "system"}}

        # Extract listening address and port
        listen_pattern = r'Server listening on (?P<ip>\S+) port (?P<port>\d+)'
        listen_match, _ = parse_regex(_content, pattern: listen_pattern)
        if !is_null(listen_match) {
          port_int, port_err = parse_int(listen_match.port)
          if port_err == null {
            ocsf.dst_endpoint = {"ip": listen_match.ip, "port": port_int}
          } else {
            ocsf.dst_endpoint = {"ip": listen_match.ip}
          }
        }

      } else if contains(_content, "Received signal") {
        # SSH service termination
        ocsf.activity_id = 99
        ocsf.activity_name = "Other"
        ocsf.type_uid = 300299  # 3002*100 + 99
        ocsf.type_name = "Authentication: Other"
        ocsf.status = "Success"
        ocsf.status_id = 1
        ocsf.status_detail = "SERVICE_TERMINATION"
        ocsf.severity_id = 1
        ocsf.severity = "Informational"
        ocsf.user = {"name": "system", "uid": "system"}
        ocsf.actor = {"user": {"name": "system", "uid": "system"}}

      } else if contains(_content, "MaxStartups throttling") {
        # Rate limiting starting
        ocsf.activity_id = 99
        ocsf.activity_name = "Other"
        ocsf.type_uid = 300299  # 3002*100 + 99
        ocsf.type_name = "Authentication: Other"
        ocsf.status = "Failure"
        ocsf.status_id = 2
        ocsf.status_code = "RATE_LIMIT_EXCEEDED"
        ocsf.status_detail = "THROTTLING_STARTED"
        ocsf.severity_id = 4
        ocsf.severity = "High"
        ocsf.user = {"name": "system", "uid": "system"}
        ocsf.actor = {"user": {"name": "system", "uid": "system"}}

      } else if contains(_content, "drop connection") || contains(_content, "past MaxStartups") {
        # Connection rate limiting / throttling
        ocsf.activity_id = 99
        ocsf.activity_name = "Other"
        ocsf.type_uid = 300299  # 3002*100 + 99
        ocsf.type_name = "Authentication: Other"
        ocsf.status = "Failure"
        ocsf.status_id = 2
        ocsf.status_code = "RATE_LIMIT_EXCEEDED"
        ocsf.status_detail = "CONNECTION_THROTTLED"
        ocsf.severity_id = 4
        ocsf.severity = "High"
        ocsf.user = {"name": "system", "uid": "system"}
        ocsf.actor = {"user": {"name": "system", "uid": "system"}}

        # Extract IP if available
        throttle_pattern = r'from \[(?P<src_ip>[^\]]+)\]'
        throttle_match, _ = parse_regex(_content, pattern: throttle_pattern)
        if !is_null(throttle_match) {
          ocsf.src_endpoint = {"ip": throttle_match.src_ip, "hostname": match.hostname}
        }

      } else if contains(_content, "exited MaxStartups throttling") {
        # Rate limiting ended
        ocsf.activity_id = 99
        ocsf.activity_name = "Other"
        ocsf.type_uid = 300299  # 3002*100 + 99
        ocsf.type_name = "Authentication: Other"
        ocsf.status = "Success"
        ocsf.status_id = 1
        ocsf.status_detail = "THROTTLING_ENDED"
        ocsf.severity_id = 2
        ocsf.severity = "Low"
        ocsf.user = {"name": "system", "uid": "system"}
        ocsf.actor = {"user": {"name": "system", "uid": "system"}}

      } else if contains(_content, "message repeated") {
        # Repeated message aggregation
        ocsf.activity_id = 99
        ocsf.activity_name = "Other"
        ocsf.type_uid = 300299  # 3002*100 + 99
        ocsf.type_name = "Authentication: Other"
        ocsf.status = "Success"
        ocsf.status_id = 1
        ocsf.status_detail = "REPEATED_MESSAGE"
        ocsf.severity_id = 1
        ocsf.severity = "Informational"

        # Try to extract repeat count
        repeat_pattern = r'message repeated (?P<count>\d+) times:'
        repeat_match, _ = parse_regex(_content, pattern: repeat_pattern)
        if !is_null(repeat_match) {
          ocsf.message = "Message repeated " + to_string(repeat_match.count) + " times"
        }

        # Extract user and IP if present in repeated message
        if contains(_content, "for invalid user") {
          user_pattern = r'for invalid user (?P<user>\S+) from'
          user_match, _ = parse_regex(_content, pattern: user_pattern)
          if !is_null(user_match) {
            ocsf.user = {"name": user_match.user, "uid": user_match.user}
            ocsf.actor = {"user": {"name": user_match.user, "uid": user_match.user}}
          }
        } else if contains(_content, "for ") {
          user_pattern = r'for\s+(?P<user>\S+) from'
          user_match, _ = parse_regex(_content, pattern: user_pattern)
          if !is_null(user_match) {
            ocsf.user = {"name": user_match.user, "uid": user_match.user}
            ocsf.actor = {"user": {"name": user_match.user, "uid": user_match.user}}
          }
        }

        # Extract IP if present
        if contains(_content, "from") {
          ip_pattern = r'from (?P<src_ip>\S+) port'
          ip_match, _ = parse_regex(_content, pattern: ip_pattern)
          if !is_null(ip_match) {
            ocsf.src_endpoint = {"ip": ip_match.src_ip, "hostname": match.hostname}
          }
        }

        # If no user found, set to unknown
        if is_null(ocsf.user) {
          ocsf.user = {"name": "unknown", "uid": "unknown"}
          ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}
        }

      } else if contains(_content, "Disconnected from user") {
        ocsf.activity_id = 2
        ocsf.activity_name = "Logoff"
        ocsf.type_uid = 300202  # 3002*100 + 2
        ocsf.type_name = "Authentication: Logoff"
        ocsf.status = "Success"
        ocsf.status_id = 1
        ocsf.status_detail = "USER_DISCONNECT"
        ocsf.severity_id = 1
        ocsf.severity = "Informational"

        # Extract user disconnect details
        user_disc_pattern = r'Disconnected from user (?P<user>\S+) (?P<src_ip>\S+) port (?P<port>\d+)'
        user_disc_match, _ = parse_regex(_content, pattern: user_disc_pattern)
        if !is_null(user_disc_match) {
          ocsf.actor = {"user": {"name": user_disc_match.user, "uid": user_disc_match.user}}
          ocsf.user = {"name": user_disc_match.user, "uid": user_disc_match.user}
          port_int, port_err = parse_int(user_disc_match.port)
          if port_err == null {
            ocsf.src_endpoint = {"ip": user_disc_match.src_ip, "hostname": match.hostname, "port": port_int}
          }
        } else {
          # Set required user field even if pattern doesn't match
          ocsf.user = {"name": "unknown", "uid": "unknown"}
          ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}
        }
      } else {
        # Catchall for unmatched sshd events
        ocsf.activity_id = 99
        ocsf.activity_name = "Other"
        ocsf.type_uid = 300299
        ocsf.type_name = "Authentication: Other"
        ocsf.status = "Success"
        ocsf.status_id = 1
        ocsf.severity_id = 1
        ocsf.severity = "Informational"
        ocsf.logon_type_id = 3  # Network
        ocsf.logon_type = "Network"
        ocsf.user = {"name": "unknown", "uid": "unknown"}
        ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}
        
        # Log unmapped pattern for debugging
        _parse_errors = push(_parse_errors, "Unmapped SSH pattern: " + truncate(to_string(match.content), limit: 100))
      }
    } else if match.process == "sudo" || contains(to_string(match.content), "sudo") {
      ocsf.activity_id = 7
      ocsf.activity_name = "Account Switch"
      ocsf.type_uid = 300207  # 3002*100 + 7
      ocsf.type_name = "Authentication: Account Switch"
      ocsf.account_switch_type = "Substitute User"
      ocsf.account_switch_type_id = 1
      ocsf.status = "Success"
      ocsf.status_id = 1
      ocsf.severity_id = 1
      ocsf.severity = "Informational"
      ocsf.is_remote = false
      ocsf.is_mfa = false
      ocsf.is_cleartext = false
      ocsf.auth_protocol = "PAM"
      ocsf.auth_protocol_id = 99  # Other - PAM not in enum
      ocsf.logon_type_id = 2  # Interactive
      ocsf.logon_type = "Interactive"

      # Set default user (will be overridden if pattern matches)
      ocsf.user = {"name": "unknown", "uid": "unknown"}
      ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}

      # Add required process.pid from parent match
      if !is_null(match.pid) {
        pid_int, pid_err = parse_int(match.pid)
        if pid_err == null {
          ocsf.logon_process.pid = pid_int
        }
      }

      # Extract sudo details
      sudo_pattern = r'(?P<user>\S+)\s*:\s*TTY=(?P<tty>\S+)\s*;\s*PWD=(?P<pwd>\S+)\s*;\s*USER=(?P<target_user>\S+)\s*;\s*COMMAND=(?P<command>.+)'
      sudo_match, _ = parse_regex(_content, pattern: sudo_pattern)
      if !is_null(sudo_match) {
        ocsf.actor = {"user": {"name": sudo_match.user, "uid": sudo_match.user}}
        ocsf.user = {"name": sudo_match.user, "uid": sudo_match.user}
        # Store target user and command in message
        ocsf.message = "sudo: " + to_string(sudo_match.user) + " -> " + to_string(sudo_match.user) + ": " + to_string(sudo_match.command)
        ocsf.status_detail = "COMMAND_EXECUTED"
      } else if contains(_content, "pam_unix") && contains(_content, "session") {
        # Try PAM session pattern for sudo
        pam_sudo_pattern = r'session\s+(?P<action>\S+)\s+for\s+user\s+(?P<user>\S+)'
        pam_sudo_match, _ = parse_regex(_content, pattern: pam_sudo_pattern)
        if !is_null(pam_sudo_match) {
          ocsf.actor = {"user": {"name": pam_sudo_match.user, "uid": pam_sudo_match.user}}
          ocsf.user = {"name": pam_sudo_match.user, "uid": pam_sudo_match.user}
          ocsf.status_detail = "SESSION_" + upcase(to_string(pam_sudo_match.action))
        }
      }
    } else if match.process == "nologin" {
      ocsf.activity_id = 1
      ocsf.activity_name = "Logon"
      ocsf.type_uid = 300201  # 3002*100 + 1
      ocsf.type_name = "Authentication: Logon"
      ocsf.status = "Failure"
      ocsf.status_id = 2
      ocsf.status_code = "ACCOUNT_DISABLED"
      ocsf.status_detail = "NOLOGIN_SHELL"
      ocsf.severity_id = 3
      ocsf.severity = "Medium"
      ocsf.is_remote = false
      ocsf.is_mfa = false
      ocsf.is_cleartext = true
      ocsf.auth_protocol = "Local"
      ocsf.auth_protocol_id = 99
      ocsf.logon_type_id = 2  # Interactive
      ocsf.logon_type = "Interactive"

      # Extract user and UID
      nologin_pattern = r'Attempted login by (?P<user>\S+)\s*\(UID:\s*(?P<uid>\d+)\)'
      nologin_match, _ = parse_regex(_content, pattern: nologin_pattern)
      if !is_null(nologin_match) {
        ocsf.actor = {"user": {"name": nologin_match.user, "uid": nologin_match.uid}}
        ocsf.user = {"name": nologin_match.user, "uid": nologin_match.uid}
        # Set logon_process with uid to satisfy OCSF constraint
        ocsf.logon_process.uid = nologin_match.uid
      }
    } else if match.process == "CRON" || contains(_content, "CRON") {
      ocsf.activity_id = 99
      ocsf.activity_name = "Other"
      ocsf.type_uid = 300299  # 3002*100 + 99
      ocsf.type_name = "Authentication: Other"
      ocsf.status = "Success"
      ocsf.status_id = 1
      ocsf.severity_id = 1
      ocsf.severity = "Informational"
      ocsf.auth_protocol = "Local"
      ocsf.auth_protocol_id = 99  # Other - Local not in enum
      ocsf.is_remote = false
      ocsf.is_mfa = false
      ocsf.is_cleartext = false
      ocsf.logon_type_id = 5  # OS Service
      ocsf.logon_type = "OS Service"
      
      # Extract cron session details
      cron_pattern = r'pam_unix\(cron:session\): session (?P<action>\S+) for user (?P<user>\S+)'
      cron_match, _ = parse_regex(_content, pattern: cron_pattern)
      if !is_null(cron_match) {
        if cron_match.action == "opened" {
          ocsf.status_detail = "SESSION_OPENED"
        } else if cron_match.action == "closed" {
          ocsf.status_detail = "SESSION_CLOSED"
        }
        ocsf.actor = {"user": {"name": cron_match.user, "uid": cron_match.user}}
        ocsf.user = {"name": cron_match.user, "uid": cron_match.user}
      }
    } else if contains(_content, "pam_unix") && contains(_content, "more authentication failure") {
      ocsf.activity_id = 6
      ocsf.activity_name = "Preauth"
      ocsf.type_uid = 300206  # 3002*100 + 6
      ocsf.type_name = "Authentication: Preauth"
      ocsf.status = "Failure"
      ocsf.status_id = 2
      ocsf.severity_id = 3
      ocsf.severity = "Medium"
      ocsf.logon_type_id = 3  # Network
      ocsf.logon_type = "Network"
      ocsf.status_code = "PAM_MULTI_FAILURE"
      
      # Extract PAM failure details - handle both singular and plural "failure(s)"
      pam_pattern = r'PAM (?P<count>\d+) more authentication failures?;.*?rhost=(?P<src_ip>\S+)(?:.*?user=(?P<user>\S+))?'
      pam_match, _ = parse_regex(_content, pattern: pam_pattern)
      if !is_null(pam_match) {
        ocsf.src_endpoint = {"ip": pam_match.src_ip, "hostname": match.hostname}
        if !is_null(pam_match.user) && pam_match.user != "" {
          ocsf.actor = {"user": {"name": pam_match.user, "uid": pam_match.user}}
          ocsf.user = {"name": pam_match.user, "uid": pam_match.user}
        } else {
          ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}
          ocsf.user = {"name": "unknown", "uid": "unknown"}
        }
        ocsf.status_detail = "PAM_" + to_string(pam_match.count) + "_FAILURES"
      }
    } else if contains(_content, "Connection reset") {
      ocsf.activity_id = 2
      ocsf.activity_name = "Logoff"
      ocsf.type_uid = 300202  # 3002*100 + 2
      ocsf.type_name = "Authentication: Logoff"
      ocsf.status = "Success"
      ocsf.status_id = 1
      ocsf.severity_id = 2
      ocsf.severity = "Low"
      ocsf.logon_type_id = 3  # Network
      ocsf.logon_type = "Network"
      ocsf.auth_protocol = "SSH"
      ocsf.auth_protocol_id = 99
      ocsf.is_remote = true
      ocsf.is_mfa = false
      ocsf.is_cleartext = false

      if contains(_content, "invalid user") {
        ocsf.status_detail = "CONNECTION_RESET_INVALID_USER"
        # Extract reset details
        reset_pattern = r'Connection reset by invalid user (?P<user>\S+) (?P<src_ip>\S+) port (?P<port>\d+)'
        reset_match, _ = parse_regex(_content, pattern: reset_pattern)
        if !is_null(reset_match) {
          ocsf.actor = {"user": {"name": reset_match.user, "uid": reset_match.user}}
          ocsf.user = {"name": reset_match.user, "uid": reset_match.user}
          ocsf.src_endpoint = {"ip": reset_match.src_ip, "hostname": match.hostname}
        } else {
          # Fallback if pattern doesn't match
          ocsf.user = {"name": "unknown", "uid": "unknown"}
          ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}
        }
      } else if contains(_content, "authenticating user") {
        ocsf.status_detail = "CONNECTION_RESET_AUTH_USER"
        # Extract reset details for authenticated user
        auth_reset_pattern = r'Connection reset by authenticating user (?P<user>\S+) (?P<src_ip>\S+) port (?P<port>\d+)'
        auth_reset_match, _ = parse_regex(_content, pattern: auth_reset_pattern)
        if !is_null(auth_reset_match) {
          ocsf.actor = {"user": {"name": auth_reset_match.user, "uid": auth_reset_match.user}}
          ocsf.user = {"name": auth_reset_match.user, "uid": auth_reset_match.user}
          ocsf.src_endpoint = {"ip": auth_reset_match.src_ip, "hostname": match.hostname}
        } else {
          # Fallback if pattern doesn't match
          ocsf.user = {"name": "unknown", "uid": "unknown"}
          ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}
        }
      } else {
        # Fallback for other connection reset types
        ocsf.status_detail = "CONNECTION_RESET"
        ocsf.user = {"name": "unknown", "uid": "unknown"}
        ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}
      }
    } else {
      ocsf.activity_id = 99
      ocsf.activity_name = "Other"
      ocsf.type_uid = 300299  # 3002*100 + 99
      ocsf.type_name = "Authentication: Other"
      ocsf.status = "Success"
      ocsf.status_id = 1
      ocsf.severity_id = 1
      ocsf.severity = "Informational"
      ocsf.is_remote = false
      ocsf.is_mfa = false
      ocsf.is_cleartext = false
      ocsf.logon_type_id = 99  # Other
      ocsf.logon_type = "Other"
      ocsf.user = {"name": "unknown", "uid": "unknown"}
      ocsf.actor = {"user": {"name": "unknown", "uid": "unknown"}}
    }
  } else {
    # Pattern match failed - set minimal required fields
    ocsf.time = _unix_ts
    ocsf.user = {"name": "unknown", "uid": "unknown"}
    ocsf.service = {"name": "unknown"}
    ocsf.message = .message
    ocsf.activity_id = 0
    ocsf.activity_name = "Unknown"
    ocsf.status = "Unknown"
    ocsf.status_id = 0
    ocsf.severity_id = 0
    ocsf.severity = "Unknown"
    ocsf.type_uid = 300200
    ocsf.type_name = "Authentication: Unknown"
  }
}

# Extract observables for threat detection
_observables = []

# Add IP address observables
if exists(ocsf.src_endpoint.ip) && !is_null(ocsf.src_endpoint.ip) {
  _observables = push(_observables, {
    "name": "src_endpoint.ip",
    "type": "IP Address", 
    "type_id": 20,
    "value": ocsf.src_endpoint.ip
  })
}

if exists(ocsf.dst_endpoint.ip) && !is_null(ocsf.dst_endpoint.ip) {
  _observables = push(_observables, {
    "name": "dst_endpoint.ip",
    "type": "IP Address",
    "type_id": 20,
    "value": ocsf.dst_endpoint.ip
  })
}

# Add user observables
if exists(ocsf.user.name) && !is_null(ocsf.user.name) && ocsf.user.name != "unknown" {
  _observables = push(_observables, {
    "name": "user.name",
    "type": "User",
    "type_id": 21,
    "value": ocsf.user.name
  })
}

# Add hostname observables
if exists(ocsf.src_endpoint.hostname) && !is_null(ocsf.src_endpoint.hostname) {
  _observables = push(_observables, {
    "name": "src_endpoint.hostname",
    "type": "Hostname",
    "type_id": 1,
    "value": ocsf.src_endpoint.hostname
  })
}

# Set observables if any were found
if length(_observables) > 0 {
  ocsf.observables = _observables
}

# Add debug info if there were parse errors (for production monitoring)
if length(_parse_errors) > 0 {
  ocsf.unmapped = {"parse_errors": _parse_errors, "original_message": .message}
  ocsf.metadata.log_level = "WARNING"
}

# Ensure user field always exists (required by OCSF)
if !exists(ocsf.user) || is_null(ocsf.user) {
  ocsf.user = {"name": "system", "uid": "system"}
  ocsf.actor = {"user": {"name": "system", "uid": "system"}}
}

# Clean up final output - remove empty arrays but keep all other fields
. = compact(ocsf, string: false, array: true, null: false, nullish: false)

# Remove internal debugging variables from final output
del(._parse_errors)
del(._observables)
del(._now_ts)
del(._unix_ts)
del(._current_year)
del(._tz_str)
